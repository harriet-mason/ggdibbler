---
title: "Know what you are uncertain about"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{barchart_problem}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
library(ggdibbler)
library(ggplot2)
library(dplyr)
library(tibble)

# make prediction diamonds data
diamonds_pred <- smaller_diamonds
diamonds_pred$cut_pred <- smaller_uncertain_diamonds$cut
diamonds_pred <- diamonds_pred |> 
  rename("cut_true" = cut) |>
  relocate(c(cut_pred, cut_true), .before = carat)
```

In showing `ggdibbler` to people, I have noticed that there are a few instances where the package does not behave in the way they expect. Sometimes this is because of a bug on the packages part, but overwhelmingly I have found that it is people people are unsure what they mean when they talk about uncertainty. 


Most exploratory visualisation software is built with safety bumpers for poorly formed questions. If you want to plot a categorical variable with no rational order to an order aesthetic, like the x position, `ggplot2` will let you. By extension, `ggdibbler` also takes this approach, however `ggdibbler` will be far less forgiving if you have made poor aesthetic and variable choices. The boundless versatility of `ggdibbler` will shoot you in the foot if you aren't careful. This will be easiest to see with an example.

Let's say we are looking at the `smaller_diamonds` dataset (which is just the `diamonds` dataset from `ggplot2`, but... smaller) and we want to predict the cut using the other variables. We make our fancy shmancy model, and then get a predicted value for each class. Since our output is a prediction, we now have a `cut_true` column, (our ground truth) and a `cut_pred` which is our predicted distribution. 

```{r}
print(head(diamonds_pred))
```
You might want to look at the uncertainty in the predicted value, so, you plot a bar chart. You might want to know how many values are predicted to be in each group. So, you make the following bar chart:

```{r}
ggplot(diamonds_pred, aes(x=cut_pred)) +
  geom_bar_sample()
```
Looking at this plot, it is clear that the count value is uncertainty, but that uncertainty is coming from the uncertainty in the cut_prediction. However, the plot makes it seem like the values are uncertain. This is the reality of the nested grammar we are using. Since the `stat_sample` that is used to get outcomes from the distribution is nested inside of ggplot's `stat_count`, the uncetainty in the prediction is carried through to the variable the plot is designed to show, i.e. the count in each category. If it makes you feel better, we can set the fill to be the outputs so you can 100% see this is the case.

```{r}
ggplot(diamonds_pred, aes(x=cut_pred)) +
  geom_bar_sample(aes(fill=factor(after_stat(x)))) +
  labs(fill = "cut_pred")
```

Of course, you can also set the fill to be a second independent draw from the prediction distribution, but this is kind of unhinged because:  

1) We are implying far more uncertainty than is actually in the bar chart (instead of drawing from one distribution, we are drawing from two independent distributions even though they represent the same variables)
2) Since `ggplot2` groups by colour, you end up with a dodged barchart inside of a dodged barchart, and it looks a bit munted.  The position adjustments are have two layers, the main plot you are suppressing, and the draw layer. The draw layers are *both* dodged in this example.

```{r}
ggplot(diamonds_pred, aes(x=cut_pred)) +
  geom_bar_sample(aes(fill= cut_pred)) 
```
The reality is, distribution variables are "slippery" in a way that deterministic variables are not. They do not have a set value, so if their position on the x axis is not set by the sample outcome.... what are they set by? The reality, is, if you want the random variables anchored to something, YOU need to decide what to anchor them to. You need to decide what your random variables are conditional on. If you want them conditional on the *deterministic* final predicted value, you need to do that. Here is an example where they are anchored to the ground truth value.

```{r}
# NEED IDENTITY DODGE OR STACK_DODGE POSITION FOR THIS TO WORK
ggplot(diamonds_pred, aes(x=cut_true)) +
  geom_bar_sample(aes(fill= cut_pred))
```

